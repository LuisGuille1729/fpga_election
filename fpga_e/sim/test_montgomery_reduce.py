import cocotb
import os
import random
import sys
import logging
from pathlib import Path
from cocotb.clock import Clock
from cocotb.triggers import Timer, ClockCycles, RisingEdge, FallingEdge, ReadOnly
from cocotb.triggers import Timer
from cocotb.utils import get_sim_time as gst
from cocotb.runner import get_runner

test_parallel = True
file_name = "montgomery_reduce_parallel" if test_parallel else "montgomery_reduce"

REGISTER_SIZE = 32
T_NUM_BLOCKS = 8192//REGISTER_SIZE
OUT_NUM_BLOCKS = 4096//REGISTER_SIZE

test_edges = True
test_our_N = True
test_arbitrary_N = True
test_detailled = False

# import sys
# sys.path.append("../../python_scripts")
# from montgomery_demo import calculate_bezout_constants
def extended_euclid_gcd(a: int, b: int):
    """
    https://www.rookieslab.com/posts/extended-euclid-algorithm-to-find-gcd-bezouts-coefficients-python-cpp-code
    Returns a list `result` of size 3 where:
    Referring to the equation ax + by = gcd(a, b)
        result[0] is gcd(a, b)
        result[1] is x
        result[2] is y 
    """
    s = 0; old_s = 1    # start 
    t = 1; old_t = 0
    r = b; old_r = a    # quotient a//b

    while r != 0:
        quotient = old_r//r # In Python, // operator performs integer or floored division
        # This is a pythonic way to swap numbers
        # See the same part in C++ implementation below to know more
        old_r, r = r, old_r - quotient*r        # gcd(a,b)
        old_s, s = s, old_s - quotient*s        # x
        old_t, t = t, old_t - quotient*t        # y
    return [old_r, old_s, old_t]    # [gcd(a,b), x, y]
def calculate_bezout_constants(N: int):
    """
    From a number N (assume it is odd), we find the values satisfying
    kN+1 = RP
    Where R is the next power of 2 larger than N
    
    Out: {N, k, R, P}
    """
    # R = 2**(N.bit_length())
    R = 2**4096

    [_, P, k] = extended_euclid_gcd(R, N)
    
    k = -k # we instead want RP = kN + 1
    
    if (k < 0):
        k += R
        P += N
    
    constants = {"N": N, "k": k, "R": R, "P": P}   # (with all values positive)
    
    return constants
 
def dispatch_blocks(value, num_blocks, infinite=True):
    while True:
        val = value
        for _ in range(num_blocks):
            yield val & (2**REGISTER_SIZE-1)
            val = val >> REGISTER_SIZE
        # print(f"Looping after {num_blocks}")
        
        if infinite is False:
            break

def check_for_block_request(dut, k_dispatcher, N_dispatcher):
    if (dut.consumed_k_out.value):
        dut.k_constant_block_in.value = next(k_dispatcher)
    if (dut.consumed_N_out.value):
        dut.modN_constant_block_in.value = next(N_dispatcher)
    # return (next(k_dispatcher), next(N_dispatcher))

async def test_reduction_outputs(dut, T, N, P, global_k_dispatcher, global_N_dispatcher):
    """
    Provides valid inputs and asserts that the outputs are exactly as expected.
    """
    expected_reduction = ((T%N)*P)%N
    expected_output_dispatcher = dispatch_blocks(expected_reduction, OUT_NUM_BLOCKS)

    T_dispatcher = dispatch_blocks(T, T_NUM_BLOCKS)

    # Provide T valid inputs
    for i in range(T_NUM_BLOCKS):
        dut.valid_in.value = 1
        T_block = next(T_dispatcher)
        dut.T_block_in.value = T_block

        check_for_block_request(dut, global_k_dispatcher, global_N_dispatcher) 
        await ClockCycles(dut.clk_in, 1)
    
    dut.valid_in.value = 0

    # Wait until start outputting result
    calculating_cycles = 0
    while dut.valid_out.value == 0:
        calculating_cycles += 1
        check_for_block_request(dut, global_k_dispatcher, global_N_dispatcher) 
        await ClockCycles(dut.clk_in, 1)
    
    # Get result
    output_cycles = 0
    while dut.valid_out.value == 1:
        output_cycles += 1
        expected_block = next(expected_output_dispatcher)
        # print(output_cycles, expected_block)
        assert dut.data_block_out.value == expected_block, f"[out cycle {output_cycles}] WRONG Output block: {int(dut.data_block_out.value)} instead of {expected_block}. T = {T}"
        
        check_for_block_request(dut, global_k_dispatcher, global_N_dispatcher) 
        await ClockCycles(dut.clk_in, 1)
    
    assert output_cycles == OUT_NUM_BLOCKS, f"Obtained wrong number ({output_cycles}) of output blocks. T = {T}"
    # print(f"Passed with T = {T}")
    
    return T_NUM_BLOCKS + calculating_cycles + output_cycles


@cocotb.test()
async def testing(dut):   
   
   
    # write your test here!
	  # throughout your test, use "assert" statements to test for correct behavior
	  # replace the assertion below with useful statements
    # default parameters are DATA_WIDTH = 8, DATA_CLK_PERIOD = 100
    dut._log.info("Starting...")
    # Start clock with 10ns period (100MHz frequency)
    cocotb.start_soon(Clock(dut.clk_in, 10, units="ns").start()) 

    # Test rst_in
    dut.rst_in.value = 1
    dut.valid_in.value = 0
    
    await ClockCycles(dut.clk_in, 10)
    dut.rst_in.value = 0
    
    await ClockCycles(dut.clk_in, 20)
    
    n_squared = 590422124689825055380819807609388189571256327875045759413123457324012204244904348160287525082997271790713457882660955619888946254261043203027771593298628441011612035265723835242026121235268765066944326490013942087806775580532770419185006727693836762421126549971166777350187227849036747874498748898200371278162103260529601535123784241275436339520934294087305771785057763906429748321306960060302877347805301757220204940169408640087558461307977499958542938818185362073916109749225361753465488257725527781630462231753011771059924172480693534542047579157001196799192378909460518139302358557373319671729492711810667118192183711386265644011686234954732739561715352966757275591394362051763747096082775428034331257483730208748244296931348278644467996131508327249311248703598496538092607531165259331139922697302096359403581744626882396938437309021732688016235359847356456980294356847006056239507114391778248012879303412205211396556204524145521662064393273536726990926093148343745926511722322805650194868790817814574744175510423873562280366546710025852968180416945163684882551407895812254630573660655532948916284348570078749620871743294686585436504822696481572626713064081970623249985910047616445949491493081152698162104745221931251546873892289
    # N_stress = random.randint(2**4094, 2**4096-1)
    # N_stress = random.randint(2**4095, 2**4096-1)
    # N_stress = N_stress|1 # make sure its odd
    N_stress = n_squared
    print("N bits: ", N_stress.bit_length())
    
    constants = calculate_bezout_constants(N_stress)
    P_stress = constants["P"]
    k_stress = constants["k"]
    # Stress test, focusing on the outputs
    global_k_dispatcher = dispatch_blocks(k_stress, OUT_NUM_BLOCKS)
    global_N_dispatcher = dispatch_blocks(N_stress, OUT_NUM_BLOCKS)   
    dut.k_constant_block_in.value = next(global_k_dispatcher)
    dut.modN_constant_block_in.value = next(global_N_dispatcher)
    
    if test_edges:
        print("Test edge cases with our n_squared")
        
        T = 548050022558420863452147844406004534810334764445592611190410074467990069360098532200836234074444859399524047609051861806731986292694398471438209724449411021456266648580896356666358387615126238819479592242561895870047496348990043453880813541722175755895240723023070190666873228375929023010989348753220945943889037120732864447077409535724753250947724985177055559031254228062327931235426731033369593752035976000616970478279409255230151398048275340920916272546020292526378446256327486892157386204526222861355034066999807551816869275032678683525803464202601648566964256416995312837300404212429763208632661530014926271860486504487038504374493771302574675377538782904042172395196574247603754495901329084498671839458565910189349516389744189706386194959638086485046658407992374370628995540989906519312171553714880611324803500793435657585445665490993876693622634203342461823076910339901192214782019923770407652019637516912282318680502946952520292161417091492632271380039530630618308056306772188107482561455735974300310534261535177340504837258953020692060094847423307480770223510272351375670023058697580037048085651819235967564586720715828741537451441649490361294185435030515215209969467344603425977110239831431612323771474125145135731071252589829374157730848812789033139594389188634469068925441078196577413188041025967545717735686250822382472843741099346693797191130824994383395609669565616467904140660665205644856522101242658754118537017058920711803983640383258076131488697687915105495120700114359355819980741289766843808019248200661689081715153091339788939853796836668768721484707739761802069239360027305991522143894253465229127553244688119253670892212200317044679231881751923673423237555788224310571438354103781006438557280827557697414876849195913823398995744847899620784261899317074245430374995104586426919119637456818095329850435870067133832834109235485795265997464946891402975980471071570869492062218108049657941099515627121094284389978001365953133105605555296401539314767415462384377392311954141356458439388984850210870049172095872468369890710364247952100842278287577449499207285746712304739160611306977235940248050593750758845054200008262120047986882806676160905372993886493497321659261219557650061015588783447302995058983766658951139232305203336010889179892240425400844781007920351500256475787481925651705650647320849449042628740486087390930405548840468768190576421643244435876497413189205866735459853116556306887959880419678192128618179345210143302028955287906638804
        cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
        print(f"Test (regression1: carry 1) successful in {cycles} cycles.") 
        
        T = 854081484672522957330109255746034479178329005034523835052860091007627073334223158176491392099062223923502407528199377613011301454494412668644941812961243697924878639391365860817310444659657911020350148303461209653743665252404133240689728306131765860015105290518974361783863644645933469961350129338740465145714681264766275002743625039127271435605878253418869269080840048202799516828482890504211021550951569801382069425547822556591128673357501275373575006870187013122963169593440557449994714235479239901144286346630175978831956111490428107023772781393533343162052360200992246012088158541357149660870221306824932240156424774693019218246833340141534587090235781505593910677024422249806452738764698407091802156344243502781089963765872127718724716281951403879657867145422186538117614928322947844073177322376214704092460193443515589968070115791422410486803371918861958059592192664003649783805591040470580365267041728691762918661896081858707377984654896840750826213808895940338259154911245327910558310859625284375156248640542426517140177577934049932861789960248615602552325489947333247732115353167065961798953457270445345478723687852060870368394779877063096384429993969506537492702222188970024722184023629255961554528583340046877621232720235848299790552623949828984907859195085182921221853817590487750269031273425926695223776888847504279369402582224700045898117698221229586119854590626429785571257557484053796894854638658712525788257749457193635363784171591295735834859654273428503116145705516010844430490993511444828189163205039039880370767044587609930284292988582772910451597959622949834464610530159059397076309618054256223636388103138230800501524159056449889905976659912977263820547142536499381127538571503551547470921633019089924748567108979328439808659187359475469206260530955923416896182311623111284698422802588020236152797147899585627516157944831508720442978454693082204294996661354995752669743660029931520679524181614947685985313691683116643129762738830330167360581205286939121840619620307409105303992007959869084999248749866384979459267826964391950373434442715940197935674745932976770354441118046428921005659060597290060901238029997695829729563057673848537844253349281319264430138290061756613416978008171777221984277302844539779941816640320777040108119091123546849691135682943541782777704033301108858223647381524011762703889452629338807209728361190306546409946268259100526396132230845233107005264018134385603097086683295326500004422322465545185770719527852301070997
        cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
        print(f"Test (regression2: carry 1) successful in {cycles} cycles.") 
        
        T = N_stress
        cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
        print(f"Test (T=N) successful in {cycles} cycles.") 
        
        T = 0
        cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
        print(f"Test (T=0) successful in {cycles} cycles.") 
        
        T = N_stress<<4096
        cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
        print(f"Test (T=RN) successful in {cycles} cycles.") 

        T = 1
        cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
        print(f"Test (T=1) successful in {cycles} cycles.")  
    
    if test_our_N:
        q = 150   # Total of 8q tests (about 5 tests per minute)
        print("Stress test with our n_squared and random T")
        for i in range(3*q):
            T = random.randint(0, N_stress<<4096)
            cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
            print(f"Test #{i} successful in {cycles} cycles. (T {T.bit_length()}-bits)")
            await ClockCycles(dut.clk_in, random.randint(0, 3))
        for i in range(3*q, 5*q):
            T = random.randint(0, N_stress)
            cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
            print(f"Test #{i} successful in {cycles} cycles. (T {T.bit_length()}-bits)")
        for i in range(5*q, 6*q):
            T = random.randint(0, N_stress//2)
            cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
            print(f"Test #{i} successful in {cycles} cycles. (T {T.bit_length()}-bits)")
        for i in range(6*q, 7*q):
            T = random.randint(0, N_stress>>1000)
            cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
            print(f"Test #{i} successful in {cycles} cycles. (T {T.bit_length()}-bits)")  
        for i in range(7*q, 8*q):
            T = random.randint(0, 2**32)
            cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
            print(f"Test #{i} successful in {cycles} cycles. (T {T.bit_length()}-bits)")  
    
    
    if test_arbitrary_N:
        print("Test for arbitrary N")
        
        for i in range(10):
            N_stress = random.randint(2**3000, 2**4096-1)
            N_stress = N_stress|1 # make sure its odd, to guarantee gcd(N,R)=1
            print(f"[{i}] New N ({N_stress.bit_length()}-bits).")
            constants = calculate_bezout_constants(N_stress)
            P_stress = constants["P"]
            k_stress = constants["k"]
            assert constants["R"]*P_stress == k_stress*N_stress + 1
            global_k_dispatcher = dispatch_blocks(k_stress, OUT_NUM_BLOCKS)
            global_N_dispatcher = dispatch_blocks(N_stress, OUT_NUM_BLOCKS)   
            dut.k_constant_block_in.value = next(global_k_dispatcher)
            dut.modN_constant_block_in.value = next(global_N_dispatcher)
            
            for j in range(3):
                T = random.randint(0, 2*N_stress)
                cycles = await test_reduction_outputs(dut, T, N_stress, P_stress, global_k_dispatcher, global_N_dispatcher)
                print(f"Test #{j} successful in {cycles} cycles. (T {T.bit_length()}-bits)")  
    
    
    # Below is a singular test useful for debugging individual signals
    if test_detailled:
        k = 143470092535370572884762559577261597060726098095130651285005957313214286020208846248841066413839665875461265127305468068675031009431615257076642373897015244136524563555490527907489468206900169957371718405066201235672090362478853663742336475964379108870711218822319915578568841927832446909576170206724004148662014335256366686051416432871380265066096266104993996707561049975588005673291226873645650089976222132906287395873762164927828399409677542706610136520339776715033573328301612875290174288048957888104513170905651338622165968798603889655834913370256159826940403775407788986108836704031341025569895498152471030201955294429901239594071770739717406269774068252071820981877376647344316707332724263561803448778502843622405588443134412694906949791848247581439427186190448488327675794671096010372437761696016989799470309941546670264823723175030798254161797471206863652908093391507702691498503852245524787840057862796014700934951893477680960594052882015846665426104688827909670722048223991884739539367655706233535869616672961157302847254190896924514009866479293385406880250829014263662616828841246401389608022822438266332289468984960397434107372764152486555063086719771617731206415603770119148562143343177455545346632889001702426541456831
        n_squared = 590422124689825055380819807609388189571256327875045759413123457324012204244904348160287525082997271790713457882660955619888946254261043203027771593298628441011612035265723835242026121235268765066944326490013942087806775580532770419185006727693836762421126549971166777350187227849036747874498748898200371278162103260529601535123784241275436339520934294087305771785057763906429748321306960060302877347805301757220204940169408640087558461307977499958542938818185362073916109749225361753465488257725527781630462231753011771059924172480693534542047579157001196799192378909460518139302358557373319671729492711810667118192183711386265644011686234954732739561715352966757275591394362051763747096082775428034331257483730208748244296931348278644467996131508327249311248703598496538092607531165259331139922697302096359403581744626882396938437309021732688016235359847356456980294356847006056239507114391778248012879303412205211396556204524145521662064393273536726990926093148343745926511722322805650194868790817814574744175510423873562280366546710025852968180416945163684882551407895812254630573660655532948916284348570078749620871743294686585436504822696481572626713064081970623249985910047616445949491493081152698162104745221931251546873892289

        # T 8192-bits long
        # T = random.randint(0, 2**8192-1)
        # print(T)
        # T = 668046964085213323677521973090209666948265322575032540699613055124432667085172110660147195335909942987381575932157651701154744675200694478842057168218319856257092368160970530081040347415486829888853873384300443737243229587670317605863427075856829719066740874768132676671162746629352571767661817548721609666404913892013504341078746142248897777527181493200187924013369452904912894553121131117914104587614068776211965526950564476248611022986277500194952900358103146560768359972800847981611729971129561286145669010687768078920716979655526158251366673764816097615550732434057345966333606248485683481426872202229099077575346510591442688826199538018447918118510915583836408992815592476509844119851550500086867335633934419423097250877496152914881242621797749639646343150830260049629685448750923091129566334277174074680079700376566832875144736678644485701380151103395141542971784164455450464060142940953936435619789783362197774298733412053523768682081350101179362750303711070175847385616841106926103577430731109938519416095022152047753921240196677811485678416759670839061024491238725905228765730129119042197897014997053754717401396872532599758105811044749808090902403767976709178484547321575816935816334126886751914357772114302676945383227384454594377992556788735411692433766101855367425417403168055542082907941434365286145923162278557766828015741019604445726546204842557463821394130597144222759876553533919466091306330854250050148420837539871813284051819162537046448242112899336599794795245264768061775712912797050164701770115699874536763426406955593191422814388010490094548861766492289118294164311658601111631881607331828087736984913563217254186457748402439745812620741623624476607508233969180499320277408788470218940968790075222388782483810351490483341945936800617061218592128646579416118200724826446132438381571348532998597425868575472926610150825562374873848918171505444401818771535686728512220744371154470662071094501903248733537974306606701759585832207275436602896065097149216109670257674250538250982245262948436799501094702203299253810679653832962054591454666483753210510397325654901214410070329488767494724285128667994314472669215355224728932912300620060647557016402657488878621905272047891310750308834734747820950450635405847680029957767794737525821942192604713231957423753924232097282651599309748814505475718805773557519681346393090263863200864563902275078204710861548716633798291290952481143604691676350197089216303821457847081364135432925556355141096836091086028
        T = 200758871690825436410313088236191628107781057906053210253817912585342046338298103685170352092366337132001123685783853513510135322026690405477252648433351062080582558313069696262403425387732936374539193247351997013421257732282759891664313583050404414398897222374531075493751726887151942583669649104032962647266220258417409777024295549116756954351583908164197993949325841224992182202441729810694966581052060861943726021703584726017714374593111741031803769758911812010720216242765577742312457580844525092150892898605279880268700009091131999101656577412617511054307704173963364710673576354285557639185312742739425647523636183952351261483563899410616902611959141616789725024297721698597187915049326438303609462934960243857368246563578082924533572725658931814558608897887398694106738814727687100061152231632939411666107174130567335581849516670591956383316266156917625265993730882770833790283807142724757957119093713954157539871036318065232021449832830895599242905265868535389526123299050171349741186236790161427715644671139127801830265648216101173206367840977170804868276432739779291538015922245676525337520512691807810204765593050601185396820183480104693118002962697431582108593056602893163758271883016323498492758125067065025416256413400979801581263269488935591616040771639463245636203910069692857928241716020854673679460318668591229430530476516854182553339097746947041107171156492075879249555322160643241599558675930730879686396380129424923460400384183432902985373026820151752659106988471340255109430510151497370443884316087780450354083927783523241061357365477736208046242520929149805093230133757269622385179063314139891842858636983576141181889993513425800255782452267650027885587705746178126482644365691100649653405137696687949431210985399793198456743006894890335037865396890822479952764208721753382106218049981411984280543033473256584584166160279066400902473189573497182292778127033803965311879935719007939752712372363912023191213891591375634436674320448915328509234407044019902185017252420039018531813789770917803491951637781953729030984082340856663104937138170106238411709005122347556045332800719320549477487192563499612564614355064212647241224463685682361784936394356278410008766771032492105963142914426582405461430178551202669778652229505038840109501321824101986317848118314120866655253449061867789573414994778068759100664085477336277946488130758772837589235115936684686498887491481497750182693099165371817228678343176374816113326928096247468637341073632122618181
        # print(T)
        # Regression:
        # T = 548050022558420863452147844406004534810334764445592611190410074467990069360098532200836234074444859399524047609051861806731986292694398471438209724449411021456266648580896356666358387615126238819479592242561895870047496348990043453880813541722175755895240723023070190666873228375929023010989348753220945943889037120732864447077409535724753250947724985177055559031254228062327931235426731033369593752035976000616970478279409255230151398048275340920916272546020292526378446256327486892157386204526222861355034066999807551816869275032678683525803464202601648566964256416995312837300404212429763208632661530014926271860486504487038504374493771302574675377538782904042172395196574247603754495901329084498671839458565910189349516389744189706386194959638086485046658407992374370628995540989906519312171553714880611324803500793435657585445665490993876693622634203342461823076910339901192214782019923770407652019637516912282318680502946952520292161417091492632271380039530630618308056306772188107482561455735974300310534261535177340504837258953020692060094847423307480770223510272351375670023058697580037048085651819235967564586720715828741537451441649490361294185435030515215209969467344603425977110239831431612323771474125145135731071252589829374157730848812789033139594389188634469068925441078196577413188041025967545717735686250822382472843741099346693797191130824994383395609669565616467904140660665205644856522101242658754118537017058920711803983640383258076131488697687915105495120700114359355819980741289766843808019248200661689081715153091339788939853796836668768721484707739761802069239360027305991522143894253465229127553244688119253670892212200317044679231881751923673423237555788224310571438354103781006438557280827557697414876849195913823398995744847899620784261899317074245430374995104586426919119637456818095329850435870067133832834109235485795265997464946891402975980471071570869492062218108049657941099515627121094284389978001365953133105605555296401539314767415462384377392311954141356458439388984850210870049172095872468369890710364247952100842278287577449499207285746712304739160611306977235940248050593750758845054200008262120047986882806676160905372993886493497321659261219557650061015588783447302995058983766658951139232305203336010889179892240425400844781007920351500256475787481925651705650647320849449042628740486087390930405548840468768190576421643244435876497413189205866735459853116556306887959880419678192128618179345210143302028955287906638804
        # T = 854081484672522957330109255746034479178329005034523835052860091007627073334223158176491392099062223923502407528199377613011301454494412668644941812961243697924878639391365860817310444659657911020350148303461209653743665252404133240689728306131765860015105290518974361783863644645933469961350129338740465145714681264766275002743625039127271435605878253418869269080840048202799516828482890504211021550951569801382069425547822556591128673357501275373575006870187013122963169593440557449994714235479239901144286346630175978831956111490428107023772781393533343162052360200992246012088158541357149660870221306824932240156424774693019218246833340141534587090235781505593910677024422249806452738764698407091802156344243502781089963765872127718724716281951403879657867145422186538117614928322947844073177322376214704092460193443515589968070115791422410486803371918861958059592192664003649783805591040470580365267041728691762918661896081858707377984654896840750826213808895940338259154911245327910558310859625284375156248640542426517140177577934049932861789960248615602552325489947333247732115353167065961798953457270445345478723687852060870368394779877063096384429993969506537492702222188970024722184023629255961554528583340046877621232720235848299790552623949828984907859195085182921221853817590487750269031273425926695223776888847504279369402582224700045898117698221229586119854590626429785571257557484053796894854638658712525788257749457193635363784171591295735834859654273428503116145705516010844430490993511444828189163205039039880370767044587609930284292988582772910451597959622949834464610530159059397076309618054256223636388103138230800501524159056449889905976659912977263820547142536499381127538571503551547470921633019089924748567108979328439808659187359475469206260530955923416896182311623111284698422802588020236152797147899585627516157944831508720442978454693082204294996661354995752669743660029931520679524181614947685985313691683116643129762738830330167360581205286939121840619620307409105303992007959869084999248749866384979459267826964391950373434442715940197935674745932976770354441118046428921005659060597290060901238029997695829729563057673848537844253349281319264430138290061756613416978008171777221984277302844539779941816640320777040108119091123546849691135682943541782777704033301108858223647381524011762703889452629338807209728361190306546409946268259100526396132230845233107005264018134385603097086683295326500004422322465545185770719527852301070997
         
        #  Regression2:
        # This T should work
        # T = 139600672039880058415680684135633881414211319163596981952329847724340364814178011869778684269249602936870977881252523236074254572444907744753247769872214728571912535223716696687053244556586222306095718206585747711315817044837503677272352380318257516112386834019588522943875159055263032817527212633458658830197302557577868179661803635287305256498107698674508430034792347058512017161818144206373063874044472710575854076957895079271131693307262776865369430906241848068867443133296780230350339224638268990058027784486872974373041583430243449397840941240529527010055332032766723746793625738718937214104975926406001276354964612281702538801307491054383364934390104320743656852550288306278433653463680569766585370300359033441079200020310108741849066020702114848177682890804445623757945849600565949813750891481344446469269712598146446213663242596595744520683510093364511713550749042155169239457836510450519695896667227813729168215112803955924241652547251716180459416699749906618375234249363844307384589560326210346097788944685191378652863178431775156326451849970651275080596421880295835392477462979885878840879948865612215940273682523805546949679944786882241690376061977683180979334632392721837264853466463778565410168422110956457545998716496098963857318852945316849277741316698365360399700632080367249948259931461364948693276127101942137975733800973368559794781154148112138885134859371708216292784767626416497346006225888563384753386084168515169541309232988770549043931822930997071438692252343052157200173898430528699922531740799719767760382540130054258635513521362830406972832271586584392755479704918910582579201279267226589977170494057813566655945810138796598830611871625580685368244650801231724310925191761778368340449073592072529549389872035396140083152418200386545707112991034942662849618843704332133283897827662575983092539182322064280886721908162151105153204089405007248031156850297708531236386512890630246421610795154602555109529653116204431558756980104385653931517659310379746451835459449588857514172075669831024692303176566280880379641123425456779070179053320046833374057489601312204823839103813189799725149717630329857466967183574747557522822039310361124844910595022386344331016064014295170050871357850178242626873926578712675085035071523939517220208956662923521566045876713327281696009114389464392248707710613281529293019338701451102500808551998936198740324520770458885909937882680250015073901266453878037153022597414578419864359750597895658816682267734065810767     

        R_exponent = 4096
        # R_inverse = pow(2, -R_exponent, n_squared)
        R_inverse = 81107639473872834862113160384587320505523681558308765561730460247589367636768099250959892926052788716221642552001139066815430567724344860583094243399736604136036937648928790764214416217951032207962309514754178084415447845641019335236679267431433119633245835662314870225975735960080986675999018544597031916700082197447731757331227648495676662127494563984609210881880262024711247896899271401123070539625781199441213299344824755371532711794411004593387207343171154694641025452736023477511533124921413766289410513644881125945554190822796304535623877818134706173653271145599695436068194617130535034171922426463589880815496060798780207388031145331065527728531271242491607203536076325279896483059756225312519985550978966934445095398386444334812097663868943921962473093468666185967862184613865127974750849105162079000335117677294111513038393051091619010878712049841141007755851239397551286050997004771575115216738471204786137390538447029669135710832418064692111189112621983088952873546418413707394233584124680888786573912063405304390478543315596591709252821498200463571641321827454439345060414450593247920183187777785231130217770494721592602618909655619784871745918950283071905258613686252409973737912390260494262666549989272981989941524185
        
        expected_reduction = (T * R_inverse) % n_squared
        
        print("Expected first block output:", expected_reduction & (2**REGISTER_SIZE -1))
        print("Expected second block output:", (expected_reduction>>REGISTER_SIZE) & (2**REGISTER_SIZE -1))
        print("Expected third block output:", (expected_reduction>>(2*REGISTER_SIZE)) & (2**REGISTER_SIZE -1))

        T_dispatcher = dispatch_blocks(T, T_NUM_BLOCKS)
        k_dispatcher = dispatch_blocks(k, OUT_NUM_BLOCKS)
        N_dispatcher = dispatch_blocks(n_squared, OUT_NUM_BLOCKS)
        
        
        dut.k_constant_block_in.value = next(k_dispatcher)
        dut.modN_constant_block_in.value = next(N_dispatcher)
        
        test_k_dipatcher = dispatch_blocks(k, OUT_NUM_BLOCKS)
        test_N_dispatcher = dispatch_blocks(n_squared, OUT_NUM_BLOCKS) 

        
        # Provide T valid inputs
        for i in range(T_NUM_BLOCKS):
            dut.valid_in.value = 1
            T_block = next(T_dispatcher)
            dut.T_block_in.value = T_block

            check_for_block_request(dut, k_dispatcher, N_dispatcher) 
            await ClockCycles(dut.clk_in, 1)

            # Test output of MOD
            assert dut.T_modR_block.value == T_block, f"[Cycle {i}] Mod out {dut.T_modR_block.value} not as expected ({T_block})"
            if i < OUT_NUM_BLOCKS:
                assert dut.T_modR_valid.value == 1
            else:
                assert dut.T_modR_valid.value == 0

            # Test input of first multiplier
            if i < OUT_NUM_BLOCKS:
                assert dut.k_constant_block_in.value == next(test_k_dipatcher)

        dut.valid_in.value = 0
        
        ### Expected stuff ###
        expected_Tk_multiplier_result = (T%(2**R_exponent)) * k
        print("First expected Tk block: ", expected_Tk_multiplier_result & (2**REGISTER_SIZE-1))
        test_Tk_multiplier_output = dispatch_blocks(expected_Tk_multiplier_result, T_NUM_BLOCKS)
        
        expected_mN_multiplier_result = (expected_Tk_multiplier_result%(2**R_exponent))*n_squared
        test_mN_multiplier_output = dispatch_blocks(expected_mN_multiplier_result, T_NUM_BLOCKS)
        
        expected_T_plus_mN_result = expected_mN_multiplier_result + T
        test_T_plus_mN_output = dispatch_blocks(expected_T_plus_mN_result, T_NUM_BLOCKS)
        
        expected_t_result = expected_T_plus_mN_result >> R_exponent
        test_t_output = dispatch_blocks(expected_t_result, OUT_NUM_BLOCKS)
        test_t_output2 = dispatch_blocks(expected_t_result, OUT_NUM_BLOCKS)

        expected_adjusted_t_result = expected_t_result if expected_t_result < n_squared else expected_t_result - n_squared
        assert expected_reduction == expected_adjusted_t_result, "Sanity check"
        
        running_t = 0
        running_N = 0
        comparison_cycle = 0
        comparison_finished_cycles = 0
        ### Continue testing ####
        
        ## TEST OUTPUTS OF MODULES INDIVUALLY
        cycles = T_NUM_BLOCKS
        while dut.valid_out.value == 0:
            cycles += 1
            
            # Test output of first multiplier (Tk)
            if dut.Tk_product_valid.value == 1:
                expected_Tk_block = next(test_Tk_multiplier_output)
                assert dut.Tk_product_block_value.value == expected_Tk_block, f"[Cycle {cycles}] Output error in Tk multiplier: Got {dut.Tk_product_block_value.value}, expected {expected_Tk_block}"

            # Test output of second multiplier (mN)
            if dut.product_Mn_valid.value == 1:
                expected_mN_block = next(test_mN_multiplier_output)
                assert dut.product_Mn_block.value == expected_mN_block, f"[Cycle {cycles}] Output error in mN multiplier: Got {dut.product_Mn_block.value}, expected {expected_mN_block}"
            
            # Test adder T + mN
            if dut.addition_T_mN_result_valid.value == 1:
                expected_T_plus_mN_block = next(test_T_plus_mN_output)
                assert dut.addition_T_mN_block.value == expected_T_plus_mN_block, f"[Cycle {cycles}] Output error in adder: Got {dut.addition_T_mN_block.value}, expected {expected_T_plus_mN_block}"

            if dut.addition_T_mN_done.value == 1:   # final out
                print("Sum Carry: ", dut.addition_T_mN_block_carry.value)
                expected_carry = expected_T_plus_mN_result >> 8192
                assert dut.addition_T_mN_block_carry.value == expected_carry, f"[Cycle {cycles}] Output error in adder CARRY: Got {dut.addition_T_mN_block_carry.value}, expected {expected_carry}"

            # Test shifter
            if dut.rshift_T_mN_byR_valid.value == 1:
                expected_t_block = next(test_t_output)
                assert dut.rshift_T_mN_byR_block.value == expected_t_block, f"[Cycle {cycles}] Output error in shift output: Got {dut.rshift_T_mN_byR_block.value}, expected {expected_t_block}"

            # Test comparison
            if dut.comparison_result.value != 0:
                # Comparing t and N
                running_t += next(test_t_output2) << (REGISTER_SIZE*comparison_cycle)
                running_N += next(test_N_dispatcher) << (REGISTER_SIZE*comparison_cycle)
                comparison_cycle += 1
                
                # print(cycles)
                # print("Expected Inputs: ", hex(running_t), hex(running_N))
                # print("Actual Inputs: ", hex(dut.t_result_block_value.value), hex(dut.modN_constant_block_in.value))
                if (running_t < running_N):
                    assert dut.comparison_result.value == 1, f"[Cycle {cycles}] Comparison error. Expected t < N, got {dut.comparison_result.value}"
                elif (running_t == running_N):
                    assert dut.comparison_result.value == 3, f"[Cycle {cycles}] Comparison error. Expected t == N, got {dut.comparison_result.value}"
                else:
                    assert dut.comparison_result.value == 2, f"[Cycle {cycles}] Comparison error. Expected t > N, got {dut.comparison_result.value}"
            
            # Test final is_t_less_than_N
            if comparison_finished_cycles != 0:
                comparison_finished_cycles += 1
            if dut.comparison_done.value == 1:
                comparison_finished_cycles += 1
                print("Comparison result: ", dut.comparison_result.value)
            

            if comparison_finished_cycles == 2:
                assert expected_t_result == (expected_carry << 4096) + running_t # sanity checking
                expected_comparison = (expected_t_result < running_N)
                print("Expected comparison:", expected_comparison, "Got comparison:", dut.is_t_less_than_N.value)
                assert dut.is_t_less_than_N.value == expected_comparison
            
            check_for_block_request(dut, k_dispatcher, N_dispatcher) 
            await ClockCycles(dut.clk_in, 1)
        
        # while dut.valid_out.value == 1:
        #     cycles += 1

        await ClockCycles(dut.clk_in, 200)

        print("Total cycles one reduction: ", cycles)
    
        # print("Expected output:")
        # t_output = dispatch_blocks(expected_adjusted_t_result, 128)
        # for _ in range(128):
        #     print(next(t_output))
 
"""the code below should largely remain unchanged in structure, though the specific files and things
specified should get updated for different simulations.
"""
def test_runner():
    """Simulate using the Python runner."""
    hdl_toplevel_lang = os.getenv("HDL_TOPLEVEL_LANG", "verilog")
    sim = os.getenv("SIM", "icarus")
    proj_path = Path(__file__).resolve().parent.parent
    sys.path.append(str(proj_path / "sim" / "model"))
    sources = [proj_path / "hdl" / (file_name + ".sv"),
               
               proj_path / "hdl" / "bram_blocks_rw.sv",
               proj_path / "hdl" / "evt_counter.sv",
               proj_path / "hdl" / "xilinx_true_dual_port_read_first_2_clock_ram.v",
               
               proj_path / "hdl" / "modulo_of_power.sv",
               
               proj_path / "hdl" / "fsm_multiplier.sv",
               proj_path / "hdl" / "fsm_multiplier_parallel.sv",
               
               proj_path / "hdl" / "pipeliner.sv", 
               
               proj_path / "hdl" / "great_adder.sv", 
               
               proj_path / "hdl" / "right_shifter.sv", 
               
               proj_path / "hdl" / "running_comparator.sv", 
               
               proj_path / "hdl" / "great_subtractor.sv"] 
    build_test_args = ["-Wall"]#,"COCOTB_RESOLVE_X=ZEROS"]
    parameters = {"REGISTER_SIZE": REGISTER_SIZE, "NUM_BLOCKS": T_NUM_BLOCKS}
    sys.path.append(str(proj_path / "sim"))
    runner = get_runner(sim)
    runner.build(
        sources=sources,
        hdl_toplevel=file_name,
        always=True,
        build_args=build_test_args,
        parameters=parameters,
        timescale = ('1ns','1ps'),
        waves=False
    )
    run_test_args = []
    runner.test(
        hdl_toplevel=file_name,
        test_module="test_montgomery_reduce",
        test_args=run_test_args,
        waves=False
    )
 
if __name__ == "__main__":
    test_runner()